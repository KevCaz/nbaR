# Netherlands Biodiversity Api
#
# Access to the digitised Natural History collection at the Naturalis Biodiversity Center
#
# OpenAPI spec version: v2
# Contact: support@naturalis.nl
# Generated by: https://github.com/swagger-api/swagger-codegen.git

#' @title Specimen operations
#' @description This client connects to all Specimen-related endpoints
#' of the NBA. Each endpoint is available as a class method
#' (see section 'Methods' below). Optionally, a custom URL
#' pointing to a NBA server and a user Agent can be specified
#' by the user (see section 'Fields' below).
#'
#' @docType class
#'
#' @format R6 class
#' 
#' @field basePath Stores url path of the request, defaults to http://api.biodiversitydata.nl/v2
#' @field userAgent Set the user agent of the request, defaults to nbaR/1.0.0
#'
#' @importFrom R6 R6Class
#'
#' @usage
#' # client <- SpecimenApi$new()
#' 
#' @section Methods:
#' \describe{
#' \item{\code{ count_distinct_values_http_get2 }}{
#'
#'   Count the distinct number of values that exist for a given field;
#'   .
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ field } : Name of field in the specimen object 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ Integer }
#' }
#' \item{\code{ count_distinct_values_http_json2 }}{
#'
#'   Count the distinct number of values that exist for a given field;
#'   .
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ field } : Name of field in the specimen object 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ Integer }
#' }
#' \item{\code{ count_distinct_values_per_group_http_get2 }}{
#'
#'   Count the distinct number of field values that exist per the given field to group by;
#'   .
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ group } : Name of field in the specimen object you want to group by \item \code{ field } : Name of field in the specimen object 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ TODO_OBJECT_MAPPING }
#' }
#' \item{\code{ count_distinct_values_per_group_http_post_json2 }}{
#'
#'   Count the distinct number of field values that exist per the given field to group by;
#'   .
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ group } : Name of field in the specimen object you want to group by \item \code{ field } : Name of field in the specimen object 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ TODO_OBJECT_MAPPING }
#' }
#' \item{\code{ count_http_get2 }}{
#'
#'   Get the number of specimens matching a given condition;
#'   Conditions given as query parameters or a querySpec JSON.
#'
#'     Parameters:
#'     \itemize{
#'         \item \code{ collection_type } : Example query param 
#'         
#'         \item \code{ queryParams } : named list or vector with query parameters 
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ Integer }
#' }
#' \item{\code{ count_http_post_json2 }}{
#'
#'   Get the number of specimens matching a given condition;
#'   Conditions given as query parameters or a querySpec JSON.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ Integer }
#' }
#' \item{\code{ download_query_http_get1 }}{
#'
#'   Dynamic download service: Query for specimens and return result as a stream ...;
#'   Query with query parameters or querySpec JSON. ....
#'
#'     Parameters:
#'     \itemize{
#'         \item \code{ collection_type } : Example query param 
#'         
#'         \item \code{ queryParams } : named list or vector with query parameters 
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{  }
#' }
#' \item{\code{ download_query_http_post_json1 }}{
#'
#'   Dynamic download service: Query for specimens and return result as a stream ...;
#'   Query with query parameters or querySpec JSON. ....
#'
#'     Parameters:
#'     \itemize{
#'         \item \code{ collection_type } : Example query param 
#'         
#'         \item \code{ queryParams } : named list or vector with query parameters 
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{  }
#' }
#' \item{\code{ dwca_get_data_set }}{
#'
#'   Download dataset as Darwin Core Archive File;
#'   Available datasets can be queried with /specimen/dwca/getDataSetNames. Response saved to &lt;datasetname&gt;-&lt;yyyymmdd&gt;.dwca.zip.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ dataset } : name of dataset 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{  }
#' }
#' \item{\code{ dwca_get_data_set_names }}{
#'
#'   Retrieve the names of all available datasets;
#'   Individual datasets can then be downloaded with /dwca/getDataSet/{dataset}.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ Character }
#' }
#' \item{\code{ dwca_query_http_get }}{
#'
#'   Dynamic download service: Query for specimens and return result as Darwin Core Archive File;
#'   Query with query parameters or querySpec JSON. Response saved to nba-specimens.dwca.zip.
#'
#'     Parameters:
#'     \itemize{
#'         \item \code{ collection_type } : Example query param 
#'         
#'         \item \code{ queryParams } : named list or vector with query parameters 
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{  }
#' }
#' \item{\code{ dwca_query_http_post_json }}{
#'
#'   Dynamic download service: Query for specimens and return result as Darwin Core Archive File;
#'   Query with query parameters or querySpec JSON. Response saved to nba-specimens.dwca.zip.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{  }
#' }
#' \item{\code{ exists }}{
#'
#'   Returns whether or not the provided unitID is a valid (in-use) unitID;
#'   Returns either true or false.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ unit_id } : the unitID of the specimen to query 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ Character }
#' }
#' \item{\code{ find3 }}{
#'
#'   Find a specimen by its Elasticsearch document ID;
#'   If found, returns a single specimen. Note that NBA document IDs are not auto-generated, so they are stable across dataset imports..
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ id } : id of specimen 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ Specimen }
#' }
#' \item{\code{ find_by_ids3 }}{
#'
#'   Find specimens by their Elasticsearch document IDs;
#'   Given multiple ids, returns a list of specimen.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ ids } : ids of multiple specimen, separated by comma 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ Specimen }
#' }
#' \item{\code{ find_by_unit_id }}{
#'
#'   Find a specimen by unitID;
#'   Get a specimen by its unitID. Returns a list of specimens since unitIDs are not strictly unique.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ unit_id } : the unitID of the specimen to query 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ Specimen }
#' }
#' \item{\code{ get_distinct_values_http_get2 }}{
#'
#'   Get all different values that exist for a field;
#'   A list of all fields for specimen documents can be retrieved with /metadata/getFieldInfo.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ field } : Name of field in specimen object 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ TODO_OBJECT_MAPPING }
#' }
#' \item{\code{ get_distinct_values_http_post_json2 }}{
#'
#'   Get all different values that exist for a field;
#'   A list of all fields for specimen documents can be retrieved with /metadata/getFieldInfo.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ field } : Name of field in specimen object 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ TODO_OBJECT_MAPPING }
#' }
#' \item{\code{ get_distinct_values_per_group2 }}{
#'
#'   Get all distinct values (and their document count) for the field given divided per distinct value of the field to group by;
#'   .
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ group } : Name of field in the specimen object you want to group by \item \code{ field } : Name of field in the specimen object 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ TODO_OBJECT_MAPPING }
#' }
#' \item{\code{ get_distinct_values_per_group_http_get2 }}{
#'
#'   Get all distinct values (and their document count) for the field given divided per distinct value of the field to group by;
#'   .
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ group } : Name of field in the specimen object you want to group by \item \code{ field } : Name of field in the specimen object 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ TODO_OBJECT_MAPPING }
#' }
#' \item{\code{ get_field_info2 }}{
#'
#'   Returns extended information for each field of a specimen document;
#'   Info consists of whether the fields is indexed, the ElasticSearch datatype and a list of allowed operators.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ TODO_OBJECT_MAPPING }
#' }
#' \item{\code{ get_paths2 }}{
#'
#'   Returns the full path of all fields within a document;
#'   See also metadata/getFieldInfo for all allowed operators per field.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ Character }
#' }
#' \item{\code{ get_settings3 }}{
#'
#'   List all publicly available configuration settings for the NBA;
#'   The value of a specific setting can be queried with metadata/getSetting/{name}.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ TODO_OBJECT_MAPPING }
#' }
#' \item{\code{ get_settings4 }}{
#'
#'   Get the value of an NBA setting;
#'   All settings can be queried with /metadata/getSettings.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ name } : name of setting 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ TODO_OBJECT_MAPPING }
#' }
#' \item{\code{ group_by_scientific_name_http_get }}{
#'
#'   Aggregates Taxon and Specimen documents according to their scientific names;
#'   Returns a list with ScientificNameGroups, which contain Taxon and Specimen documents that share a scientific name.
#'
#'     Parameters:
#'     \itemize{
#'         \item \code{ collection_type } : Example query param 
#'         
#'         \item \code{ queryParams } : named list or vector with query parameters 
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ QueryResult }
#' }
#' \item{\code{ group_by_scientific_name_http_post_json }}{
#'
#'   Aggregates Taxon and Specimen documents according to their scientific names;
#'   Returns a list with ScientificNameGroups, which contain Taxon and Specimen documents that share a scientific name.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ QueryResult }
#' }
#' \item{\code{ is_operator_allowed2 }}{
#'
#'   Checks if a given operator is allowed for a given field;
#'   See also metadata/getFieldInfo.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         \item \code{ field } : specimen document field \item \code{ operator } : operator 
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ TODO_OBJECT_MAPPING }
#' }
#' \item{\code{ query_http_get2 }}{
#'
#'   Query for specimens;
#'   Search for specimens (GET) using query parameters or a querySpec JSON.
#'
#'     Parameters:
#'     \itemize{
#'         \item \code{ collection_type } : Example query param 
#'         
#'         \item \code{ queryParams } : named list or vector with query parameters 
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ QueryResult }
#' }
#' \item{\code{ query_http_post_json2 }}{
#'
#'   Query for specimens;
#'   Search for specimens (POST) using a JSON-serialized QuerySpec in de request body.
#'
#'     Parameters:
#'     \itemize{
#'         
#'         
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{ QueryResult }
#' }
#' \item{\code{ query_with_name_resolution_http_get1 }}{
#'
#'   ;
#'   .
#'
#'     Parameters:
#'     \itemize{
#'         \item \code{ _query_spec } :  
#'         
#'         \item \code{ queryParams } : named list or vector with query parameters 
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{  }
#' }
#' \item{\code{ query_with_name_resolution_http_post_json1 }}{
#'
#'   ;
#'   .
#'
#'     Parameters:
#'     \itemize{
#'         
#'         
#'         
#'         
#'         \item \code{ ... } : additional parameters passed to httr::GET
#'     }
#'     Returns:
#'         \code{  }
#' }
#' }
#'
#' @export
SpecimenApi <- R6::R6Class(
    "SpecimenApi",
    inherit = ApiClient,
    public = list(
        initialize = function(basePath, userAgent){
        super$initialize(basePath, userAgent)
    },

      count_distinct_values_http_get2 = function(
          field = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/countDistinctValues/{field}"
            
        if (!missing(`field`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "field", "\\}"), `field`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "primitive type", return vector or single value
            result <- as.Integer(httr::content(response))
            Response$new(result, response)
        }        
    },
      count_distinct_values_http_json2 = function(
          field = NULL,
          body = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        if (!missing(`body`)) {
            body <- `body`$toJSONString()
        } else {
            body <- NULL
        }

        urlPath <- "/specimen/countDistinctValues/{field}"
            
        if (!missing(`field`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "field", "\\}"), `field`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "POST",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "primitive type", return vector or single value
            result <- as.Integer(httr::content(response))
            Response$new(result, response)
        }        
    },
      count_distinct_values_per_group_http_get2 = function(
          group = NULL,
          field = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/countDistinctValuesPerGroup/{group}/{field}"
            
        if (!missing(`group`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "group", "\\}"), `group`, urlPath)
        }

            
        if (!missing(`field`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "field", "\\}"), `field`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "list container"
            result <- lapply(httr::content(response),
                             function(x) {
                                 cl <- returnObject$clone()
                                 cl$fromList(x,
                                 typeMapping = list(item = private$getBaseDataType()))
                                 })
            Response$new(result, response)
        }        
    },
      count_distinct_values_per_group_http_post_json2 = function(
          group = NULL,
          field = NULL,
          body = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        if (!missing(`body`)) {
            body <- `body`$toJSONString()
        } else {
            body <- NULL
        }

        urlPath <- "/specimen/countDistinctValuesPerGroup/{group}/{field}"
            
        if (!missing(`group`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "group", "\\}"), `group`, urlPath)
        }

            
        if (!missing(`field`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "field", "\\}"), `field`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "POST",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "list container"
            result <- lapply(httr::content(response),
                             function(x) {
                                 cl <- returnObject$clone()
                                 cl$fromList(x,
                                 typeMapping = list(item = private$getBaseDataType()))
                                 })
            Response$new(result, response)
        }        
    },
      count_http_get2 = function(
          collectionType = NULL,
          queryParams = list(),
          ... ) {
        headerParams <- character()
        if (!is.null(querySpec) & length(queryParams) > 0) {
            stop("Either querySpec or queryParams argument allowed, not both.")
        }
            
        if (!missing(`collectionType`)) {
          ## querySpec can be either JSON string or object of type QuerySpec. 
          param <- ifelse(typeof(`collectionType`) == "environment",
                          `collectionType`$toJSONString(),
                          `collectionType`)    
          queryParams["collectionType"] <- param
        }
        ## querySpec parameter has underscore in NBA, omitted in argument
        names(queryParams) <- gsub("querySpec",
                                    "_querySpec",
                                    names(queryParams))

        urlPath <- "/specimen/count"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "primitive type", return vector or single value
            result <- as.Integer(httr::content(response))
            Response$new(result, response)
        }        
    },
      count_http_post_json2 = function(
          body = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        if (!missing(`body`)) {
            body <- `body`$toJSONString()
        } else {
            body <- NULL
        }

        urlPath <- "/specimen/count"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "POST",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "primitive type", return vector or single value
            result <- as.Integer(httr::content(response))
            Response$new(result, response)
        }        
    },
      download_query_http_get1 = function(
          collectionType = NULL,
          queryParams = list(),
          ... ) {
        headerParams <- character()
        if (!is.null(querySpec) & length(queryParams) > 0) {
            stop("Either querySpec or queryParams argument allowed, not both.")
        }
            
        if (!missing(`collectionType`)) {
          ## querySpec can be either JSON string or object of type QuerySpec. 
          param <- ifelse(typeof(`collectionType`) == "environment",
                          `collectionType`$toJSONString(),
                          `collectionType`)    
          queryParams["collectionType"] <- param
        }
        ## querySpec parameter has underscore in NBA, omitted in argument
        names(queryParams) <- gsub("querySpec",
                                    "_querySpec",
                                    names(queryParams))

        urlPath <- "/specimen/download"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## empty response, e.g. when file is downloaded
            result <- NULL
            Response$new(result, response)
        }        
    },
      download_query_http_post_json1 = function(
          body = NULL,
          collectionType = NULL,
          queryParams = list(),
          ... ) {
        headerParams <- character()
        if (!is.null(querySpec) & length(queryParams) > 0) {
            stop("Either querySpec or queryParams argument allowed, not both.")
        }
            
        if (!missing(`collectionType`)) {
          ## querySpec can be either JSON string or object of type QuerySpec. 
          param <- ifelse(typeof(`collectionType`) == "environment",
                          `collectionType`$toJSONString(),
                          `collectionType`)    
          queryParams["collectionType"] <- param
        }
        ## querySpec parameter has underscore in NBA, omitted in argument
        names(queryParams) <- gsub("querySpec",
                                    "_querySpec",
                                    names(queryParams))

        if (!missing(`body`)) {
            body <- `body`$toJSONString()
        } else {
            body <- NULL
        }

        urlPath <- "/specimen/download"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "POST",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## empty response, e.g. when file is downloaded
            result <- NULL
            Response$new(result, response)
        }        
    },
      dwca_get_data_set = function(
          dataset = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/dwca/getDataSet/{dataset}"
            
        if (!missing(`dataset`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "dataset", "\\}"), `dataset`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## empty response, e.g. when file is downloaded
            result <- NULL
            Response$new(result, response)
        }        
    },
      dwca_get_data_set_names = function(
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/dwca/getDataSetNames"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "primitive type", return vector or single value
            result <- as.Character(httr::content(response))
            Response$new(result, response)
        }        
    },
      dwca_query_http_get = function(
          collectionType = NULL,
          queryParams = list(),
          ... ) {
        headerParams <- character()
        if (!is.null(querySpec) & length(queryParams) > 0) {
            stop("Either querySpec or queryParams argument allowed, not both.")
        }
            
        if (!missing(`collectionType`)) {
          ## querySpec can be either JSON string or object of type QuerySpec. 
          param <- ifelse(typeof(`collectionType`) == "environment",
                          `collectionType`$toJSONString(),
                          `collectionType`)    
          queryParams["collectionType"] <- param
        }
        ## querySpec parameter has underscore in NBA, omitted in argument
        names(queryParams) <- gsub("querySpec",
                                    "_querySpec",
                                    names(queryParams))

        urlPath <- "/specimen/dwca/query"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## empty response, e.g. when file is downloaded
            result <- NULL
            Response$new(result, response)
        }        
    },
      dwca_query_http_post_json = function(
          body = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        if (!missing(`body`)) {
            body <- `body`$toJSONString()
        } else {
            body <- NULL
        }

        urlPath <- "/specimen/dwca/query"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "POST",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## empty response, e.g. when file is downloaded
            result <- NULL
            Response$new(result, response)
        }        
    },
      exists = function(
          unitID = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/exists/{unitID}"
            
        if (!missing(`unitID`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "unitID", "\\}"), `unitID`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "primitive type", return vector or single value
            result <- as.Character(httr::content(response))
            Response$new(result, response)
        }        
    },
      find3 = function(
          id = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/find/{id}"
            
        if (!missing(`id`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "id", "\\}"), `id`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is object of model class
            returnObject <- Specimen$new()
            ## if API call result is QueryResult,
            ## list items must be mapped to model class            
            result <- returnObject$fromList(
                httr::content(response),
                  typeMapping = list(item = private$getBaseDataType()))
            Response$new(result, response)
        }        
    },
      find_by_ids3 = function(
          ids = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/findByIds/{ids}"
            
        if (!missing(`ids`)) {
            ## build URL for path param
            ## input can be vector or string with comma separated items
            ## API takes string, so translate vector, if present
            if (length(`ids`) > 1) {
                ids <- paste(ids, collapse=",")
            }
            urlPath <- gsub(paste0("\\{", "ids", "\\}"), `ids`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is object of model class
            returnObject <- Specimen$new()
            ## API call result is "list container"
            result <- lapply(httr::content(response),
                             function(x) {
                                 cl <- returnObject$clone()
                                 cl$fromList(x,
                                 typeMapping = list(item = private$getBaseDataType()))
                                 })
            Response$new(result, response)
        }        
    },
      find_by_unit_id = function(
          unitID = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/findByUnitID/{unitID}"
            
        if (!missing(`unitID`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "unitID", "\\}"), `unitID`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is object of model class
            returnObject <- Specimen$new()
            ## API call result is "list container"
            result <- lapply(httr::content(response),
                             function(x) {
                                 cl <- returnObject$clone()
                                 cl$fromList(x,
                                 typeMapping = list(item = private$getBaseDataType()))
                                 })
            Response$new(result, response)
        }        
    },
      get_distinct_values_http_get2 = function(
          field = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/getDistinctValues/{field}"
            
        if (!missing(`field`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "field", "\\}"), `field`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is a "map container" and will be parsed to list 
            result <- httr::content(response, simplifyVector = TRUE)
            Response$new(result, response)
        }        
    },
      get_distinct_values_http_post_json2 = function(
          field = NULL,
          body = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        if (!missing(`body`)) {
            body <- `body`$toJSONString()
        } else {
            body <- NULL
        }

        urlPath <- "/specimen/getDistinctValues/{field}"
            
        if (!missing(`field`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "field", "\\}"), `field`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "POST",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is a "map container" and will be parsed to list 
            result <- httr::content(response, simplifyVector = TRUE)
            Response$new(result, response)
        }        
    },
      get_distinct_values_per_group2 = function(
          group = NULL,
          field = NULL,
          body = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        if (!missing(`body`)) {
            body <- `body`$toJSONString()
        } else {
            body <- NULL
        }

        urlPath <- "/specimen/getDistinctValuesPerGroup/{group}/{field}"
            
        if (!missing(`group`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "group", "\\}"), `group`, urlPath)
        }

            
        if (!missing(`field`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "field", "\\}"), `field`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "POST",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "list container"
            result <- lapply(httr::content(response),
                             function(x) {
                                 cl <- returnObject$clone()
                                 cl$fromList(x,
                                 typeMapping = list(item = private$getBaseDataType()))
                                 })
            Response$new(result, response)
        }        
    },
      get_distinct_values_per_group_http_get2 = function(
          group = NULL,
          field = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/getDistinctValuesPerGroup/{group}/{field}"
            
        if (!missing(`group`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "group", "\\}"), `group`, urlPath)
        }

            
        if (!missing(`field`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "field", "\\}"), `field`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "list container"
            result <- lapply(httr::content(response),
                             function(x) {
                                 cl <- returnObject$clone()
                                 cl$fromList(x,
                                 typeMapping = list(item = private$getBaseDataType()))
                                 })
            Response$new(result, response)
        }        
    },
      get_field_info2 = function(
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/metadata/getFieldInfo"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is a "map container" and will be parsed to list 
            result <- httr::content(response, simplifyVector = TRUE)
            Response$new(result, response)
        }        
    },
      get_paths2 = function(
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/metadata/getPaths"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is "primitive type", return vector or single value
            result <- as.Character(httr::content(response))
            Response$new(result, response)
        }        
    },
      get_settings3 = function(
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/metadata/getSettings"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is a "map container" and will be parsed to list 
            result <- httr::content(response, simplifyVector = TRUE)
            Response$new(result, response)
        }        
    },
      get_settings4 = function(
          name = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/metadata/getSetting/{name}"
            
        if (!missing(`name`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "name", "\\}"), `name`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## if API call result is QueryResult,
            ## list items must be mapped to model class            
            result <- returnObject$fromList(
                httr::content(response),
                  typeMapping = list(item = private$getBaseDataType()))
            Response$new(result, response)
        }        
    },
      group_by_scientific_name_http_get = function(
          collectionType = NULL,
          queryParams = list(),
          ... ) {
        headerParams <- character()
        if (!is.null(querySpec) & length(queryParams) > 0) {
            stop("Either querySpec or queryParams argument allowed, not both.")
        }
            
        if (!missing(`collectionType`)) {
          ## querySpec can be either JSON string or object of type QuerySpec. 
          param <- ifelse(typeof(`collectionType`) == "environment",
                          `collectionType`$toJSONString(),
                          `collectionType`)    
          queryParams["collectionType"] <- param
        }
        ## querySpec parameter has underscore in NBA, omitted in argument
        names(queryParams) <- gsub("querySpec",
                                    "_querySpec",
                                    names(queryParams))

        urlPath <- "/specimen/groupByScientificName"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is object of model class
            returnObject <- QueryResult$new()
            ## if API call result is QueryResult,
            ## list items must be mapped to model class            
            result <- returnObject$fromList(
                httr::content(response),
                  typeMapping = list(item = private$getBaseDataType()))
            Response$new(result, response)
        }        
    },
      group_by_scientific_name_http_post_json = function(
          body = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        if (!missing(`body`)) {
            body <- `body`$toJSONString()
        } else {
            body <- NULL
        }

        urlPath <- "/specimen/groupByScientificName"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "POST",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is object of model class
            returnObject <- QueryResult$new()
            ## if API call result is QueryResult,
            ## list items must be mapped to model class            
            result <- returnObject$fromList(
                httr::content(response),
                  typeMapping = list(item = private$getBaseDataType()))
            Response$new(result, response)
        }        
    },
      is_operator_allowed2 = function(
          field = NULL,
          operator = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        urlPath <- "/specimen/metadata/isOperatorAllowed/{field}/{operator}"
            
        if (!missing(`field`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "field", "\\}"), `field`, urlPath)
        }

            
        if (!missing(`operator`)) {
            ## build URL for path param
            urlPath <- gsub(paste0("\\{", "operator", "\\}"), `operator`, urlPath)
        }

        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is a "map container" and will be parsed to list 
            result <- httr::content(response, simplifyVector = TRUE)
            Response$new(result, response)
        }        
    },
      query_http_get2 = function(
          collectionType = NULL,
          queryParams = list(),
          ... ) {
        headerParams <- character()
        if (!is.null(querySpec) & length(queryParams) > 0) {
            stop("Either querySpec or queryParams argument allowed, not both.")
        }
            
        if (!missing(`collectionType`)) {
          ## querySpec can be either JSON string or object of type QuerySpec. 
          param <- ifelse(typeof(`collectionType`) == "environment",
                          `collectionType`$toJSONString(),
                          `collectionType`)    
          queryParams["collectionType"] <- param
        }
        ## querySpec parameter has underscore in NBA, omitted in argument
        names(queryParams) <- gsub("querySpec",
                                    "_querySpec",
                                    names(queryParams))

        urlPath <- "/specimen/query"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is object of model class
            returnObject <- QueryResult$new()
            ## if API call result is QueryResult,
            ## list items must be mapped to model class            
            result <- returnObject$fromList(
                httr::content(response),
                  typeMapping = list(item = private$getBaseDataType()))
            Response$new(result, response)
        }        
    },
      query_http_post_json2 = function(
          body = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        if (!missing(`body`)) {
            body <- `body`$toJSONString()
        } else {
            body <- NULL
        }

        urlPath <- "/specimen/query"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "POST",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## API call result is object of model class
            returnObject <- QueryResult$new()
            ## if API call result is QueryResult,
            ## list items must be mapped to model class            
            result <- returnObject$fromList(
                httr::content(response),
                  typeMapping = list(item = private$getBaseDataType()))
            Response$new(result, response)
        }        
    },
      query_with_name_resolution_http_get1 = function(
          _querySpec = NULL,
          queryParams = list(),
          ... ) {
        headerParams <- character()
        if (!is.null(querySpec) & length(queryParams) > 0) {
            stop("Either querySpec or queryParams argument allowed, not both.")
        }
            
        if (!missing(`_querySpec`)) {
          ## querySpec can be either JSON string or object of type QuerySpec. 
          param <- ifelse(typeof(`_querySpec`) == "environment",
                          `_querySpec`$toJSONString(),
                          `_querySpec`)    
          queryParams["_querySpec"] <- param
        }
        ## querySpec parameter has underscore in NBA, omitted in argument
        names(queryParams) <- gsub("querySpec",
                                    "_querySpec",
                                    names(queryParams))

        urlPath <- "/specimen/queryWithNameResolution"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "GET",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## empty response, e.g. when file is downloaded
            result <- NULL
            Response$new(result, response)
        }        
    },
      query_with_name_resolution_http_post_json1 = function(
          body = NULL,
          ... ) {
        headerParams <- character()
        queryParams <- list()
        if (!missing(`body`)) {
            body <- `body`$toJSONString()
        } else {
            body <- NULL
        }

        urlPath <- "/specimen/queryWithNameResolution"
        response <- self$callApi(url = paste0(self$basePath, urlPath),
                                 method = "POST",
                                 queryParams = as.list(queryParams),
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

        if (httr::status_code(response) < 200 ||
               httr::status_code(response) > 299) {
            self$handleError(response)
        } else {
            ## empty response, e.g. when file is downloaded
            result <- NULL
            Response$new(result, response)
        }        
    },
    print = function(...) {
       ## print class name
       cat("<SpecimenApi>\n")
       cat("\tInherits from: <ApiClient>\n\n")
       ## print all members with values
       cat("Fields:\n")
       cat("\tbasePath:\t", self$basePath, "\n")
       cat("\tuserAgent:\t", self$userAgent, "\n")
       ## print all methods
       cat("Methods:\n")
           cat("\tcount_distinct_values_http_get2", "\n")
           cat("\tcount_distinct_values_http_json2", "\n")
           cat("\tcount_distinct_values_per_group_http_get2", "\n")
           cat("\tcount_distinct_values_per_group_http_post_json2", "\n")
           cat("\tcount_http_get2", "\n")
           cat("\tcount_http_post_json2", "\n")
           cat("\tdownload_query_http_get1", "\n")
           cat("\tdownload_query_http_post_json1", "\n")
           cat("\tdwca_get_data_set", "\n")
           cat("\tdwca_get_data_set_names", "\n")
           cat("\tdwca_query_http_get", "\n")
           cat("\tdwca_query_http_post_json", "\n")
           cat("\texists", "\n")
           cat("\tfind3", "\n")
           cat("\tfind_by_ids3", "\n")
           cat("\tfind_by_unit_id", "\n")
           cat("\tget_distinct_values_http_get2", "\n")
           cat("\tget_distinct_values_http_post_json2", "\n")
           cat("\tget_distinct_values_per_group2", "\n")
           cat("\tget_distinct_values_per_group_http_get2", "\n")
           cat("\tget_field_info2", "\n")
           cat("\tget_paths2", "\n")
           cat("\tget_settings3", "\n")
           cat("\tget_settings4", "\n")
           cat("\tgroup_by_scientific_name_http_get", "\n")
           cat("\tgroup_by_scientific_name_http_post_json", "\n")
           cat("\tis_operator_allowed2", "\n")
           cat("\tquery_http_get2", "\n")
           cat("\tquery_http_post_json2", "\n")
           cat("\tquery_with_name_resolution_http_get1", "\n")
           cat("\tquery_with_name_resolution_http_post_json1", "\n")
       cat("\tping\n")
       invisible(self)
    }
  )
)

